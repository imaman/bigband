import * as util from 'util';
import * as child_process from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as uuidv1 from 'uuid/v1';
import * as os from 'os';
import * as del from 'del'
import * as mkdirp from 'mkdirp'

import { logger } from './logger';
import { AwsFactory, DeployableFragment } from 'bigband-core'
import { BigbandLambdaInstallation } from 'bigband-lambda'
import { DepsCollector } from './DepsCollector'
import { NpmPackageResolver } from './NpmPackageResolver'
import { BigbandInstallation } from 'bigband-core';
import { GetFunctionResponse, InvocationRequest, InvocationResponse } from 'aws-sdk/clients/lambda';
import { Teleporter, S3BlobPool } from './Teleporter';
import { S3Ref } from './S3Ref';
import { ZipBuilder } from './ZipBuilder';
import { CONTRIVED_NPM_PACAKGE_NAME, CONTRIVED_IN_FILE_NAME, CONTRIVED_OUT_FILE_NAME } from './scotty'
import { Misc } from './Misc';
import { ResolvedName } from './ResolvedName';
import { Spawner } from './Spawner';

export enum DeployMode {
  ALWAYS = 1,
  IF_CHANGED = 2
}

export interface PushResult {
  deployableLocation: S3Ref
  wasPushed: boolean,
  existed: boolean
}



export class Packager {
  private readonly workingDir: string;
  private workingDirCreated = false;
  private readonly npmPackageDir;

  constructor(private readonly rootDir: string, npmPackageDir: string, private readonly awsFactory: AwsFactory,
      private readonly blobPool: S3BlobPool, private readonly fragment: DeployableFragment) {    
    if (!path.isAbsolute(npmPackageDir)) {
      throw new Error(`Expected an absolute path but got ${npmPackageDir}.`);
    }
    this.npmPackageDir = path.resolve(npmPackageDir);
    if (this.npmPackageDir.endsWith('node_modules')) {
      throw new Error(`npmPackageDir (${npmPackageDir}) must be the parent of a node_modules directory (i.e., a directory which also has a package.json file).`);
    }
    this.workingDir = path.resolve(os.tmpdir(), "packager-" + uuidv1());
    if (!path.isAbsolute(this.workingDir)) {
      throw new Error(`Assertion failed: workingDir must be absoulte, but it was not (${this.workingDir})`);
    }
  }

  private async compile(relativeTsFile: string, relativeOutDir: string, nameInSection: string) {
    const outDir = this.newOutDir(relativeOutDir);

    
    // TODO(imaman): magic constant
    const autogeneratedDir = this.toAbs('autogenerated')

    // TODO(imaman): this duplicates code from ZipBuilder.unzip()
    const dir = path.resolve(autogeneratedDir, nameInSection)
    if (fs.existsSync(dir)) {
      await del([dir], {force: true})
    }

    mkdirp.sync(dir)
    fs.writeFileSync(path.resolve(autogeneratedDir, '.gitignore'), '*', 'UTF-8')

    // TODO(imaman): computation of starting point is a bit weird. perhaps a more explicit way?
    const startingPoints: string[] = []
    this.fragment.forEach(curr => {
      const p = path.resolve(dir, curr.path)

      if (p.endsWith('.ts')) {
        startingPoints.push(p)
      }
      fs.writeFileSync(p, curr.content, 'UTF-8')
    })

    // const filesToCompile = startingPoints.map(curr => (`"${curr}"`)).join(' ')
    // logger.silly(`Compiling ${st}`);

    let args: string[] = ['--outDir', outDir, '--preserveConstEnums', '--strictNullChecks', '--sourceMap', 
        '--target', 'es2015', '--module', 'commonjs', '--allowJs', '--checkJs', 'false', '--lib', 'es2015,dom', 
        '--rootDir', this.rootDir]
    args = args.concat(startingPoints)

    const execution = await Spawner.exec('tsc', args, this.rootDir)
    if (execution.exitCode !== 0) {
      logger.info(`Compilation of ${startingPoints} failed:\n${execution.stderr}\n${execution.stdout}`)
      process.exit(-1)
    }

    return outDir;
  }
  
  private async createZip(relativeTsFile: string, npmPackageName: string): Promise<ZipBuilder> {
    const absoluteTsFile = this.toAbs(relativeTsFile);
    logger.silly('Packing dependencies of ' + absoluteTsFile);

    const npmPackageResolver = new NpmPackageResolver(
        [this.npmPackageDir, BigbandLambdaInstallation.bigbandLambdaPackageDir(), Misc.bigbandPackageDir()],
        shouldBeIncluded);
    await npmPackageResolver.prepopulate();

    const isScotty = relativeTsFile === CONTRIVED_IN_FILE_NAME;
    if (isScotty) {
      // This should reflect the immediate deps of scotty.ts
      npmPackageResolver.recordUsage('jszip');
      npmPackageResolver.recordUsage('mkdirp');
      npmPackageResolver.recordUsage('hash.js');
    } else if (npmPackageName) {
      npmPackageResolver.recordUsage(npmPackageName);
    } else {
      const deps = DepsCollector.scanFrom(absoluteTsFile);
      for (const d of deps.npmDeps) {
        npmPackageResolver.recordUsage(d)
      }
    }
    const usageByPackageName = npmPackageResolver.compute();  
    const zipBuilder = new ZipBuilder();
    const nodeModulesFragment = zipBuilder.newFragment();
    for (const k in usageByPackageName) {
      const usage = usageByPackageName[k];
      nodeModulesFragment.scan(`node_modules/${usage.packageName}`, usage.dir);
    }


    return zipBuilder;
  }

  public async run(relativeTsFile: string, relativeOutDir: string, npmPackageName: string, nameInSection: string): Promise<ZipBuilder> {
    logger.silly(`Packing ${relativeTsFile} into ${relativeOutDir}`);

    const compiledFilesDir = npmPackageName ? '' : await this.compile(relativeTsFile, relativeOutDir, nameInSection);
    const zipBuilder = await this.createZip(relativeTsFile, npmPackageName);  
    if (compiledFilesDir.length) {
      zipBuilder.newFragment().scan('build', compiledFilesDir);
    } 

    // Special treatment for scotty.
    if (relativeTsFile === CONTRIVED_IN_FILE_NAME) {
      const frag = zipBuilder.newFragment();
      frag.addText('node_modules/bigband-core/index.js',
          BigbandInstallation.exportBigbandCoreSourceCode('DeployableFragment.js'));
      frag.addText(`node_modules/${CONTRIVED_NPM_PACAKGE_NAME}/${CONTRIVED_OUT_FILE_NAME}`,
          fs.readFileSync(path.resolve(__dirname, 'scotty.js'), 'utf-8'));
      frag.addText(`node_modules/${CONTRIVED_NPM_PACAKGE_NAME}/ZipBuilder.js`,
          fs.readFileSync(path.resolve(__dirname, 'ZipBuilder.js'), 'utf-8'));
      const handler = `
          const {runLambda} = require('${CONTRIVED_NPM_PACAKGE_NAME}/${CONTRIVED_OUT_FILE_NAME}');
          const mapping = require('../../../bigband/deps.js');
          const fp = require('../../../bigband/build_manifest.js');

          function handle(event, context, callback) {
              try {
                  Promise.resolve()
                  .then(() => runLambda(context, event, mapping, fp))
                  .then(response => callback(null, response))
                  .catch(e => {
                      console.error('Exception caught from promise flow (event=\\n:' + JSON.stringify(event).substring(0, 1000) + ")\\n\\n", e);
                      callback(e);
                  });
              } catch (e) {
                  console.error('Exception caught:', e);
                  callback(e);
              }
          }

          module.exports = {handle};
      `;

      frag.addText(`build/autogenerated/${nameInSection}/handler.js`, handler)
    }
    
    return zipBuilder;
  }

  public unzip(zipBuilder: ZipBuilder, relativeOutDir: string) {
    const outDir = this.newOutDir(relativeOutDir);
    zipBuilder.unzip(outDir);
    return outDir;
  }

  public async pushToS3(name: ResolvedName, deployableLocation: S3Ref, zipBuilder: ZipBuilder,
      teleportLambdaName: string, teleportingEnabled: boolean, deployMode: DeployMode, 
      printMessage: boolean): Promise<PushResult> {      

    const logFunc = printMessage ? (x: string) => logger.info(x) : (x: string) => logger.silly(x)


    // TODO(imaman): can we get this information earlier to reduce possible waiting?
    const existsPromise = S3Ref.exists(this.awsFactory, deployableLocation)


    const lambda = this.awsFactory.newLambda()
    // TODO(imaman): ditto, get earlier
    const p = lambda.getFunction({FunctionName: name.physicalName}).promise()
      .catch(e => null)
    const buf = await zipBuilder.toBuffer();
    const fingeprint = ZipBuilder.bufferTo256Fingerprint(buf);
    const getFunctionResponse: GetFunctionResponse|null = await p;
    let c = getFunctionResponse && getFunctionResponse.Configuration && getFunctionResponse.Configuration.CodeSha256;

    const ret: PushResult = {
      deployableLocation,
      wasPushed: true,
      existed: Boolean(getFunctionResponse)
    };

    const exists = await existsPromise 
    if (!exists) {
      logger.silly(`Previous deployment of ${name.physicalName} was not found`)
    }

    // fs.writeFileSync('/tmp/out.zip', await zipBuilder.toBuffer())

    logger.silly(`Comparing fingerprints for ${name.fullyQualifiedName}:\n  ${c}\n  ${fingeprint}`);
    if (deployMode === DeployMode.IF_CHANGED) {
      if (exists && c && c == fingeprint) {
        logFunc(`No code changes in ${name.fullyQualifiedName}`);
        ret.wasPushed = false;
        return ret;
      }
    }
    
    if (!this.blobPool) {
      throw new Error('a blob pool was not specified');
    }
    const teleporter = new Teleporter(this.blobPool);
    const handlePojos = (await teleporter.teleport(zipBuilder)).map(curr => curr.toPojo()); 

    const teleportRequest = {
      deployables: handlePojos,
      destination: deployableLocation.toPojo()
    }

    const invocationRequest: InvocationRequest = {
      FunctionName: teleportLambdaName,
      InvocationType: 'RequestResponse', 
      Payload: JSON.stringify({teleportRequest})
    };
    
    if (teleportingEnabled) {
      try {
        const invocationResponse: InvocationResponse = await lambda.invoke(invocationRequest).promise();
        if (invocationResponse.FunctionError) {
          logger.silly('teleporter returned an error:\n' + JSON.stringify(invocationResponse));
          throw new Error(`Teleporting of ${name.physicalName} failed: ${invocationResponse.FunctionError}`);
        }
        logFunc(`Updated ${name.fullyQualifiedName} (${formatBytes(teleporter.bytesSent)})`)
        return ret;
      } catch (e) {
        logger.silly('Teleporting error', e);
      }  
    }

    const numBytes = await teleporter.nonIncrementalTeleport(zipBuilder, deployableLocation)
    logFunc(`Pushed ${formatBytes(numBytes)} for ${name.fullyQualifiedName}`)
    return ret;
  }


  private toAbs(relativeFile: string) {
    if (path.isAbsolute(relativeFile)) {
      throw new Error('File to compile cannot be absolute');
    }
  
    if (relativeFile.startsWith('.')) {
      throw new Error('File to compile cannot start with a dot');
    }
    return path.resolve(this.rootDir, relativeFile);
  }

  private newOutDir(name) {
    if (path.dirname(name) !== '.') {
      throw new Error(`name (${name} must be a plain (pathless) name.`);
    }
    const ret = path.resolve(this.workingDir, name);

    if (!this.workingDirCreated) {
      fs.mkdirSync(this.workingDir);
      this.workingDirCreated = true;
    }
    fs.mkdirSync(ret);
    return ret;
  }
}

function shouldBeIncluded(packageName: string) {
  return packageName !== 'aws-sdk' && !packageName.startsWith('aws-sdk/') && packageName !== CONTRIVED_NPM_PACAKGE_NAME;
}

function formatBytes(n: number) {
  return `${(n / (1024 * 1024)).toFixed(3)}MB`
}


// Deployment size from a sample section
//
// Incl. dev deps:
//     Shipping rig "prod" to eu-central-1
//     Compiling tagging-backend
//     Compiling tagging-scoreAll
//     Compiling tagging-scoreTaggingSet
//     Compiling tagging-scoreTaggingPair
//     Compiling bigband-scotty
//     Non-teleporting deployment (0.532MB) of bigband-scotty
//     Non-teleporting deployment (0.035MB) of tagging-scoreAll
//     Non-teleporting deployment (0.049MB) of tagging-scoreTaggingSet
//     Non-teleporting deployment (0.690MB) of tagging-backend
//     Non-teleporting deployment (3.999MB) of tagging-scoreTaggingPair
//     No stack changes
//     Rig "prod" shipped in 40.0s
//
// Excl. dev deps:
//     Shipping rig "prod" to eu-central-1
//     Compiling tagging-backend
//     Compiling tagging-scoreAll
//     Compiling tagging-scoreTaggingSet
//     Compiling tagging-scoreTaggingPair
//     Compiling bigband-scotty
//     Non-teleporting deployment (0.297MB) of bigband-scotty
//     Non-teleporting deployment (0.035MB) of tagging-scoreAll
//     Non-teleporting deployment (0.049MB) of tagging-scoreTaggingSet
//     Non-teleporting deployment (0.690MB) of tagging-backend
//     Non-teleporting deployment (3.999MB) of tagging-scoreTaggingPair
//     No stack changes
//     Rig "prod" shipped in 41.5s
